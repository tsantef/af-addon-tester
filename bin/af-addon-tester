#!/usr/bin/env ruby

lib = File.expand_path(File.dirname(__FILE__) + '/../lib')
$LOAD_PATH.unshift(lib) if File.directory?(lib) && !$LOAD_PATH.include?(lib)

require 'rubygems'
require 'json'
require 'digest/sha1'
require 'af-addon-tester'

manifest_path = ARGV.first

begin
  manifest_file = File.open(File.expand_path(manifest_path), 'r')
  manifest_json = manifest_file.readlines.to_s
  manifest = JSON.parse(manifest_json)

  raise "Missing id" if manifest['id'].nil?
  raise "Missing api section" if manifest['api'].nil?
  raise "Missing api password" if manifest['api']['password'].nil?
  raise "Missing apt test url" if manifest['api']['test'].nil?
  raise "Manifest must have atleast one plan" if manifest['api']['plans'].nil? || manifest['api']['plans'][0].nil? || manifest['api']['plans'][0]['id'].nil?
  raise "missing api config_vars" if manifest['api']['config_vars'].nil?
  raise "Missing api sso_salt" if manifest['api']['sso_salt'].nil?

rescue Exception => e
  puts bwhite "#{e.message}. Please specify a valid manifest file."
  exit
end

callback_url = 'http://localhost:9990'
config_prefix = manifest['id'].gsub('-','_').upcase + '_'
bad_user = 'bad_user'
bad_password = 'bad_pass'

addon = Rest.new(manifest['api']['test'], manifest['id'], manifest['api']['password'])
resp = nil

validate "Provisioning" do
  params = {}
  payload = { 'customer_id' => manifest['id'], 'plan' => manifest['api']['plans'][0]['id'], 'callback_url' => callback_url, 'options' => '{}' }
  resp = addon.post(manifest['api']['test'], params, JSON.generate(payload))
  failed("response code: #{resp.code} - #{resp.message}") if resp.code != "200"
  passed
end

  if resp.code == "200"
  provision_info = nil
  validate "Valid JSON response" do
    begin
      provision_info = JSON.parse(resp.body)
    rescue Exception => e 
      failed e.message
    end
    passed
  end

  unless provision_info.nil?
    validate "Response params" do
      begin
        failed("Missing 'id'") if provision_info['id'].nil? || provision_info['id'] == ""
      rescue Exception => e 
        failed e.message
      end
      passed
    end

    unless provision_info['config'].nil?
      validate "All config keys are in manifest" do
        provision_info['config'].each do |key, value|
          unless manifest['api']['config_vars'].include? key; failed "#{key} not found in config"; end
        end
      end

      validate "All manifest config keys are in response" do
        manifest['api']['config_vars'].each do |key, value|
          unless provision_info['config'].include? key; failed "#{key} not found in manifest"; end
        end
      end

      validate "All config keys are prefixed with addon name" do
        provision_info['config'].each do |key, value|
          unless key.start_with? config_prefix; failed "#{key} does not begin with #{config_prefix}"; end
        end
        passed
      end
    end

    resource_id = provision_info['id']
    unless resource_id.nil?
      validate "Update resource" do
        params = {}
        payload = { 'plan' => 'paid', 'callback_url' => callback_url, 'options' => '{}' }
        resp = addon.put(manifest['api']['test'] + "/#{resource_id}", params, JSON.generate(payload))
        failed("response code: #{resp.code}") if resp.code != "200"
        passed
      end

      READLEN = 1024 * 10
      reader, writer = IO.pipe
      out = nil
      validate "Callback" do
        child = fork do
          reader.close
          server = TCPServer.open(9990)
          client = server.accept
          writer.write(client.readpartial(READLEN))
          client.write("HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n")
          client.close
          writer.close
        end
        sleep(1)
        out = reader.readpartial(READLEN)
        passed
      end

      callback_info = nil    
      isValidCallback = false
      validate "Valid callback response" do
        _, json = out.split("\r\n\r\n")
        begin
          callback_info = JSON.parse(json)
        rescue Exception => e 
          failed e.message
        end
        isValidCallback = true
        passed
      end

      if isValidCallback
        validate "All callback config keys are in manifest" do
          callback_info['config'].each do |key, value|
            unless manifest['api']['config_vars'].include? key; failed "#{key} not found in config"; end
          end
        end

        validate "All callback manifest config keys are in response" do
          manifest['api']['config_vars'].each do |key, value|
            unless callback_info['config'].include? key; failed "#{key} not found in manifest"; end
          end
        end

        validate "All callback config keys are prefixed with addon name" do
          callback_info['config'].each do |key, value|
            unless key.start_with? config_prefix; failed "#{key} does not begin with #{config_prefix}"; end
          end
          passed
        end
      end

      validate "SSO link" do
        timestamp = Time.now.to_i
        authstring = resource_id.to_s + ':' + manifest['api']['sso_salt'] + ':' + timestamp.to_s
        token = Digest::SHA1.hexdigest(authstring)
        resp = addon.get(manifest['api']['test'] + "/#{resource_id}?token=#{token}&timestamp=#{timestamp}")
        passed unless resp.code != "200"
      end

      validate "Deprovision" do
        params = {}
        payload = { 'customer_id' => manifest['id'], 'plan' => manifest['api']['plans'][0]['id'], 'callback_url' => callback_url, 'options' => '{}' }
        resp = addon.delete(manifest['api']['test'] + "/#{resource_id}", params, JSON.generate(payload))
        failed("response code: #{resp.code}") if resp.code != "200"
        passed
      end

    end
  end

else
  false
end

validate "Bad credentials test" do
  params = {}
  payload = { 'customer_id' => manifest['id'], 'plan' => manifest['api']['plans'][0]['id'], 'callback_url' => callback_url, 'options' => '{}' }

  addon_bad_auth = Rest.new(manifest['api']['test'], bad_user, bad_password)
  resp = addon.post(manifest['api']['test'], params, JSON.generate(payload))

  failed if resp.code == "200"
  passed
end
